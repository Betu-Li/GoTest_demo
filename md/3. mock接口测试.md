 除了网络和数据库等外部依赖之外，我们在开发中也会经常用到各种各样的接口类型。本文就举例来演示如何在编写单元测试的时候对接口类型进行mock以及如何进行打桩。

在单元测试中使用gomock和gostub工具mock接口和打桩。

## gomock

[gomock](https://github.com/uber-go/mock)是Go官方提供的测试框架，它在内置的testing包或其他环境中都能够很方便的使用。我们使用它对代码中的那些接口类型进行mock，方便编写单元测试。

### 安装mockgen

安装 `mockgen` 工具：


```zsh
go install go.uber.org/mock/mockgen@latest
```

### 运行mockgen

`mockgen` 有两种操作模式：源码（source）模式和反射（reflect）模式。

#### 源码（source） 模式

源码模式根据源文件mock接口。它是通过使用 `-source` 标志启用。在这个模式下可能有用的其他标志是 `-imports` 和 `-aux_files`。

```zsh
mockgen -source=foo.go [other options]
```

#### 反射（reflect）模式

Reflect模式通过构建一个使用反射来理解接口的程序来生成模拟接口。通过传递两个非标志参数来启用它：导入路径和逗号分隔的符号列表。

可以使用“.”来引用当前路径的包。

```zsh
mockgen database/sql/driver Conn,Driver

# Convenient for `go:generate`.
mockgen . Conn,Driver
```

#### Flags

`mockgen` 命令用来为给定一个包含要mock的接口的Go源文件，生成mock类源代码。它支持以下标志：

- `-source`：包含要mock的接口的文件。
- `-destination`：生成的源代码写入的文件。如果不设置此项，代码将打印到标准输出。
- `-package`：用于生成的模拟类源代码的包名。如果不设置此项包名默认在原包名前添加`mock_`前缀。
- `-imports`：在生成的源代码中使用的显式导入列表。值为foo=bar/baz形式的逗号分隔的元素列表，其中bar/baz是要导入的包，foo是要在生成的源代码中用于包的标识符。
- `-aux_files`：需要参考以解决的附加文件列表，例如在不同文件中定义的嵌入式接口。指定的值应为foo=bar/baz.go形式的以逗号分隔的元素列表，其中bar/baz.go是源文件，foo是`-source`文件使用的文件的包名。
- `-build_flags`：（仅反射模式）一字不差地传递标志给go build
- `-mock_names`：生成的模拟的自定义名称列表。这被指定为一个逗号分隔的元素列表，形式为`Repository = MockSensorRepository,Endpoint=MockSensorEndpoint`，其中`Repository`是接口名称，`mockSensorrepository`是所需的mock名称(mock工厂方法和mock记录器将以mock命名)。如果其中一个接口没有指定自定义名称，则将使用默认命名约定。
- `-self_package`：生成的代码的完整包导入路径。使用此flag的目的是通过尝试包含自己的包来防止生成代码中的循环导入。如果mock的包被设置为它的一个输入(通常是主输入)，并且输出是stdio，那么mockgen就无法检测到最终的输出包，这种情况就会发生。设置此标志将告诉 mockgen 排除哪个导入
- `-copyright_file`：用于将版权标头添加到生成的源代码中的版权文件
- `-debug_parser`：仅打印解析器结果
- `-exec_only`：（反射模式） 如果设置，则执行此反射程序
- `-prog_only`：（反射模式）只生成反射程序；将其写入标准输出并退出。
- `-write_package_comment`：如果为true，则写入包文档注释 (godoc)。（默认为true）

### 构建 Mocks

官方提供的例子：

```go
// Foo 接口，实现Bar方法
type Foo interface {
  Bar(x int) int
}

// SUT 方法，参数是Foo接口
func SUT(f Foo) {
 // ...
}
```

```go
func TestFoo(t *testing.T) {
  // 创建gomock控制器，用来记录后续的操作信息
  ctrl := gomock.NewController(t)
  
  // 调用mockgen生成代码中的NewMockFoo方法
  m := NewMockFoo(ctrl)

  // 打桩（stub）
  // 当传入Bar函数的参数为99时返回101
  // Asserts that the first and only call to Bar() is passed 99.
  // Anything else will fail.
  m.
    EXPECT().
    Bar(gomock.Eq(99)).
    Return(101)
    
  // 调用SUT函数时传入上面的mock对象m
  SUT(m)
}
```

以日常开发中经常用到的数据库操作为例：

假设有查询MySQL数据库的业务代码如下，其中`DB`是一个自定义的接口类型：

```go
// db.go

// DB 数据接口
type DB interface {
	Get(key string)(int, error)
	Add(key string, value int) error
}


// GetFromDB 根据key从DB查询数据的函数
func GetFromDB(db DB, key string) int {
	if v, err := db.Get(key);err == nil{
		return v
	}
	return -1
}
```

现在要为`GetFromDB`函数编写单元测试代码，可是我们又不能在单元测试过程中连接真实的数据库，这个时候就需要`mock DB`这个接口来方便进行单元测试。

使用 `mockgen` 生成 `db_mock.go`。一般传递三个参数。包含需要被mock的接口得到源文件`source`，生成的目标文件`destination`，包名`package`。

通过执行下面的命令，我们就能在当前项目下生成一个`code/mocks_demo`文件夹，里面存放了一个`db_mock.go`文件。

```bash
 mockgen -source=code/mock_demo/db.go -destination=code/mock_demo/db_mock.go -package=mock_demo
```

`db_mock.go`文件中的内容就是mock相关接口的代码了。

我们通常不需要编辑它，只需要在单元测试中按照规定的方式使用它们就可以了。例如，我们编写`TestGetFromDB` 函数如下：

```go
// db_test.go

func TestGetFromDB(t *testing.T) {
	// 创建gomock控制器，用来记录后续的操作信息
	ctrl := gomock.NewController(t)
	// 断言期望的方法都被执行
	// Go1.14+的单测中不再需要手动调用该方法
	defer ctrl.Finish()
	// 调用mockgen生成代码中的NewMockDB方法
	// 这里mocks是我们生成代码时指定的package名称
	m := mocks.NewMockDB(ctrl)
	// 打桩（stub）
	// 当传入Get函数的参数为liwenzhou.com时返回1和nil
	m.
		EXPECT().
		Get(gomock.Eq("betuli")). // 参数
		Return(1, nil).                  // 返回值
		Times(1)                         // 调用次数

	// 调用GetFromDB函数时传入上面的mock对象m
	if v := GetFromDB(m, "betuli"); v != 1 {
		t.Fatal()
	}
}

```
### 打桩（stub）

软件测试中的打桩是指用一些代码（桩stub）代替目标代码，通常用来屏蔽或补齐业务逻辑中的关键代码方便进行单元测试。

> [!NOTE]
> 屏蔽：不想在单元测试用引入数据库连接等重资源
> 
> 补齐：依赖的上下游函数或方法还未实现

上面代码中就用到了打桩，当传入`Get`函数的参数为`betuli` 时就返回`1, nil`的返回值。

`gomock`支持针对参数、返回值、调用次数、调用顺序等进行打桩操作。

#### 参数

参数相关的用法有：

- `gomock.Eq(value)`：表示一个等价于value值的参数
- `gomock.Not(value)`：表示一个非value值的参数
- `gomock.Any()`：表示任意值的参数
- `gomock.Nil()`：表示空值的参数
- `SetArg(n, value)`：设置第n（从0开始）个参数的值，通常用于指针参数或切片

具体示例如下：

```go
m.EXPECT().Get(gomock.Not("betuli")).Return(10, nil) // 非value值的参数
m.EXPECT().Get(gomock.Any()).Return(20, nil) // 任意值的参数
m.EXPECT().Get(gomock.Nil()).Return(-1, nil) // 空值的参数
```

这里单独说一下`SetArg`的适用场景，假设你有一个需要mock的接口如下：

```go
type YourInterface {
  SetValue(arg *int)
}
```

此时，打桩的时候就可以使用`SetArg`来修改参数的值。

```go
m.EXPECT().SetValue(gomock.Any()).SetArg(0, 7)  // 将SetValue的第一个参数设置为7
```

#### 返回值

gomock中跟返回值相关的用法有以下几个：

- `Return()`：返回指定值
- `Do(func)`：执行操作，忽略返回值
- `DoAndReturn(func)`：执行并返回指定值

例如：

```go
m.EXPECT().Get(gomock.Any()).Return(20, nil)// 任意值的参数，返回值为20，nil
m.EXPECT().Get(gomock.Any()).Do(func(key string) {
	t.Logf("input key is %v\n", key)
})// 执行返回操作
m.EXPECT().Get(gomock.Any()).DoAndReturn(func(key string)(int, error) {
	t.Logf("input key is %v\n", key)
	return 10, nil
})// 执行操作，并返回10，nil
```

#### 调用次数

使用gomock工具mock的方法都会有期望被调用的次数，默认每个mock方法只允许被调用一次。

```go
m.
	EXPECT().
	Get(gomock.Eq("liwenzhou.com")). // 参数
	Return(1, nil).                  // 返回值
	Times(1)                         // 设置Get方法期望被调用次数为1

// 调用GetFromDB函数时传入上面的mock对象m
if v := GetFromDB(m, "liwenzhou.com"); v != 1 {
	t.Fatal()
}
// 再次调用上方mock的Get方法时不满足调用次数为1的期望
if v := GetFromDB(m, "liwenzhou.com"); v != 1 {
	t.Fatal()
}
```

gomock为我们提供了如下方法设置期望被调用的次数。

- `Times()` 断言 Mock 方法被调用的次数。
- `MaxTimes()` 最大次数。
- `MinTimes()` 最小次数。
- `AnyTimes()` 任意次数（包括 0 次）。

#### 调用顺序

gomock还支持使用`InOrder`方法指定mock方法的调用顺序：

```go
// 指定顺序
gomock.InOrder(
	m.EXPECT().Get("1"),
	m.EXPECT().Get("2"),
	m.EXPECT().Get("3"),
)

// 按顺序调用
GetFromDB(m, "1")
GetFromDB(m, "2")
GetFromDB(m, "3")
```

此外知名的Go测试库[testify](https://github.com/stretchr/testify)目前也提供类似的mock工具—`testify/mock`和`mockery`。

## GoStub

[GoStub](https://github.com/prashantv/gostub)也是一个单元测试中的打桩工具，它支持为全局变量、函数等打桩。

不过个人感觉它为函数打桩不太方便，一般在单元测试中只会使用它来为全局变量打桩。

### 安装

```bash
go get github.com/prashantv/gostub
```

### 使用示例

这里使用官方文档中的示例代码演示如何使用gostub为全局变量打桩。

```go
// app.go 

var (
	configFile = "config.json"
	maxNum = 10
)


func GetConfig() ([]byte, error) {
	return ioutil.ReadFile(configFile)
}


func ShowNumber()int{
	// ...
	return maxNum
}
```

上面代码中定义了两个全局变量和两个使用全局变量的函数，我们现在为这两个函数编写单元测试。

```go
// app_test.go


import (
	"github.com/prashantv/gostub"
	"testing"
)

func TestGetConfig(t *testing.T) {
	// 为全局变量configFile打桩，给它赋值一个指定文件
	stubs := gostub.Stub(&configFile, "./test.toml")
	defer stubs.Reset()  // 测试结束后重置
	// 下面是测试的代码
	data, err := GetConfig()
	if err != nil {
		t.Fatal()
	}
	// 返回的data的内容就是上面/tmp/test.config文件的内容
	t.Logf("data:%s\n", data)
}

func TestShowNumber(t *testing.T) {
	stubs := gostub.Stub(&maxNum, 20)
	defer stubs.Reset()
	// 下面是一些测试的代码
	res := ShowNumber()
	if res != 20 {
		t.Fatal()
	}
}
```

执行单元测试，查看结果：

```bash
go test -v
=== RUN   TestGetConfig
    app_test.go:20: data:test:betuli
--- PASS: TestGetConfig (0.00s)
=== RUN   TestShowNumber
--- PASS: TestShowNumber (0.00s)
PASS
```

从上面的示例中我们可以看到，在单元测试中使用`gostub`可以很方便的对全局变量进行打桩，将其mock成我们预期的值从而进行测试。b

